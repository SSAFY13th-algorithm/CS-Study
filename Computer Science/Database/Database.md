
# 인덱스
## 인덱스란?
<details>
  <summary><b>인덱스란에 대해 설명해 주세요.</b></summary>  
  
  데이터베이스 인덱스는 데이터 검색 작업의 속도를 향상시키는 자료구조이며, 데이터를 빠르게 찾을 수 있도록 도와줍니다.

특정 컬럼에 대해 생성되며, 이 인덱스는 해당 컬럼의 값과 해당 레코드가 저장된 물리적 위치 정보를 가집니다. 쿼리를 실행하면, 테이블 전체를 스캔하는 대신 인덱스를 먼저 확인하여 필요한 데이터의 위치를 빠르게 찾아낼 수 있습니다.

인덱스는 디스크에 별도의 데이터 구조로 저장되며, 메모리에 로드되어 처리됩니다.

인덱스가 없다면 모든 데이터 페이지를 순차적으로 검색해야 하지만, 인덱스를 사용하면 필요한 데이터가 있는 페이지만 접근할 수 있습니다.
</details>
<br/>
<details>
  <summary><b>인덱스의 장점을 설명해 주세요.</b></summary>
  
  1. 검색 성능 향상  
    인덱스는 대체로 B+tree의 형태로 구성되기 때문에 데이터 조회 연산의 시간 복잡도를 $O(N)$에서 $O(\log{N})$으로 개선합니다.  


  2. 정렬 비용 감소  
    인덱스가 이미 정렬되어 있기 때문에 ORDER BY 절의 정렬 작업이 최적화됩니다. 


  3. join 연산 최적화  
    외래 키에 인덱스를 생성하는 경우 join 연산을 더 효율적으로 수행합니다. 검색 성능 향상의 연장선이라고도 볼 수 있는데, PK 값과 FK 값을 비교할 때 전체 데이터를 확인할 필요 없이 필요한 데이터만 검색하면 되므로 쿼리 성능이 높아지는 것입니다. 
</details>

## 인덱스의 자료구조
<details>
  <summary><b>B Tree</b></summary>

![](/Computer%20Science/Database/image/B-Tree.png)  
  - 모든 리프 노드가 같은 레벨에 존재하고, 노드 내 데이터는 항상 정렬된 상태를 유지합니다.   
  - 모든 노드에 데이터를 저장할 수 있고, 리프 노드들이 서로 연결되어 있지 않습니다.   
  - 내부 노드는 데이터와 키를 함께 저장합니다.   
  - 노드의 데이터 수가 n개라면 자식 노드의 개수는 n+1개입니다.
</details>
<br/>
<details>
  <summary><b>B+Tree</b></summary>

![](/Computer%20Science/Database/image/B__Tree.png)  
  - 리프 노드에만 데이터를 저장합니다.   
  - 리프 노드들은 연결 리스트로 연결되어 순차 접근이 용이합니다.   
  - 따라서, 내부 노드는 키 값만 저장하며 인덱스 역할만 수행합니다. 
</details>
<br/>

<details>
    <summary><b>Hash Table</b></summary>

- 해시 함수를 사용하여 키를 해싱하고, 해시 테이블에 저장합니다.
- 해시 테이블은 해시 값과 해당하는 데이터 레코드의 포인터를 저장합니다. 
- 검색 시 해시 값을 계산하여 해당하는 위치로 바로 이동하여 데이터를 찾을 수 있습니다. → 일반적으로 $O(1)$ 의 시간 복잡도를 가지게 됩니다.

</details>
<br/>
<details>
    <summary><b>B-Tree와 B+Tree 인덱스의 차이점을 설명하고, 각각 어떤 상황에서 더 효율적인지 설명해 주세요.</b></summary>

B-Tree와 B+Tree의 주요 차이점은 데이터 저장 방식과 I/O 작업 방식의 차이가 있습니다. B-Tree는 모든 노드에 키와 데이터를 함께 저장하는 반면, B+Tree는 내부 노드에 키만 저장하고 실제 데이터는 리프 노드에만 저장합니다. 따라서 B-tree는 단일 레코드 검색이 주로 필요한 상황에서 유리하고, B+Tree는 범위 검색이 빈번한 곳에서 효율적입니다. 

B+Tree에서 단일 레코드 검색 시, 리프 노드까지 가야 하므로 B-Tree에 비해 느리고 B-Tree에서 범위 검색 시 시작점과 끝점의 페이지를 확인해야 해서 B+Tree에 비해 느립니다.
</details>
<br/>
<details>
    <summary><b>B-Tree와 Hash 인덱스의 차이점을 설명해주세요.</b></summary>

해시테이블은 단일 행 접근은 빠를 수 있으나 key값이 달라지면 해시함수을 거쳐 value가 달라지기 때문에 다중 행 접근에 대해서 불가한 점이 있습니다. <br/>

B-Tree는 단일 행 접근은 해시테이블보다 느릴지라도 다중 행 접근과 함께 사용할 수 있다는 장점이 있습니다.

</details>

## 클러스터드 인덱스 vs 넌클러스터드 인덱스
<details>
    <summary><b>클러스터드 인덱스</b></summary>

클러스터드 인덱스를 구성하기 위해서 행 데이터를 인덱스로 설정할 열로 정렬한 후에, 루트 페이지를 만들게 됩니다. <br>
즉, 물리적으로 행을 재배열 합니다.

테이블 당 하나의 클러스터드 인덱스만 존재할 수 있습니다.

클러드터드 인덱스 순서로 레코드들이 하드디스크에 저장됩니다. 클러스터드 인덱스를 따로 지정하지 않으면, 기본 키가 클러스터드 인덱스가 됩니다.<br>
즉, 테이블 생성 시 Primary Key(PK)를 지정하면, 그 컬럼은 자동으로 클러스터드 인덱스가 만들어집니다.
</details>
<br/>
<details>
    <summary><b>넌클러스터드 인덱스</b></summary>

레코드의 원본은 정렬하지 않고, 인덱스 페이지만 정렬됩니다. 넌클러스터드 인덱스는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성합니다.

인덱스 페이지의 리프 페이지에 <u>인덱스로 구성한 열을 정렬</u> 한 후 위치 포인터(RID)를 생성합니다. 즉, 넌클러스터드 인덱스의 인덱스 페이지(리프 페이지)는 키값과 데이터가 위치하는 포인터(RID)로 구성됩니다.

<u>넌클러스터드 인덱스는 여러 인덱스를 사용할 수 있어, 여러 연산에 최적화할 수 있는 유연성을 제공합니다.</u>

 > 포인터(RID): '파일그룹번호+데이터페이지 번호 + 페이지 내의 로우 번호'으로 구성되는 포인팅 정보입니다.
</details>
<br/>
<details>
    <summary><b>클러스터드 인덱스와 넌클러스터드 인덱스의 차이는 무엇인가요?</b></summary>

클러스터드 인덱스는 테이블의 실제 데이터를 인덱스 키값에 따라 물리적으로 정렬하고 저장하는 방식입니다. <br>
테이블 당 하나만 존재할 수 있으며, 주로 PK에 자동으로 생성됩니다. <br>
클러스터드 인덱스는 실제 데이터가 인덱스와 함께 저장되므로 검색 시 매우 빠릅니다.

넌클러스터드 인덱스는 실제 데이터와 별도로 생성되며, 인덱스 키값과 실제 데이터를 찾아갈 수 있는 포인터를 저장합니다. <br>
한 테이블에 여러 개 생성할 수 있고, 인덱스 자체는 정렬되지만 실제 데이터는 물리적으로 재배열하지 않습니다. <br>
넌클러스터드 인덱스를 통한 조회는 넌클러스터드 인덱스에서 1번, 실제 데이터를 조회할 때 1번, 총 두번 디스크 접근이 있어 클러스터드 인덱스보다 느리지만, 자주 사용되는 검색 키나 정렬이 필요한 컬럼에 생성해 성능을 최적화할 수 있습니다.
</details>